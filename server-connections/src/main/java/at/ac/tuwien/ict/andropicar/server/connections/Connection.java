package at.ac.tuwien.ict.andropicar.server.connections;


import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import at.ac.tuwien.ict.andropicar.json.JSONDecoder;
import at.ac.tuwien.ict.andropicar.server.Server;
import at.ac.tuwien.ict.andropicar.server.helper.EOperationType;
import at.ac.tuwien.ict.andropicar.server.helper.Keywords;
import at.ac.tuwien.ict.andropicar.server.helper.QueueElement;


/**
 * This abstract runnable provides basic functionality to communicate with any device that is connected to this server via a TCP-connection.<br>
 * This class holds the reference to exactly one TCP-connection with another device, which means that every connection is handled in its own thread.<br>
 * Basic functionalities are:<br>
 * -) Write and read Strings to and from the TCP-Socket that connects the server to the device.<br>
 * -) Write and read JSON Strings to and from the TCP-Socket that can be generated by HashMaps.<br>
 * -) inform the main thread about certain events via the operationQueue.<br>
 * <br>
 * The class also contains a list of listeners that can register themselves to get informed about data that is received via this classes TCP-connection.<br>
 * <br>
 * <b>Following is a list of JSON-Keywords, that can be part of a message (value range not enforced by server):</b><br>
 * <table>
 * <caption></caption>
 * 	<tr>
 * 		<th><b>Key</b></th>
 * 		<th><b>Value range/type</b></th>
 * 		<th><b>Description</b></th>
 * 	</tr>
 * 	<tr>
 * 		<td>id</td>
 * 		<td>long or String</td>
 * 		<td>to register at the server. A String stands for a phone-ID, a long stands for a car-ID</td>
 * 	</tr>
 *  <tr>
 * 		<td>connect</td>
 * 		<td>0...99999</td>
 * 		<td>to connect a phone to a car in order to control it.<br>0 represents a request to disconnect.</td>
 * 	</tr>
 *  <tr>
 * 		<td>state</td>
 * 		<td>-1...2</td>
 * 		<td>to get informed about id and connect requests<br>(-1 not allowed, 0 not connected to a phone, 1 identified, 2 connected to a phone)</td>
 * 	</tr>
 *  <tr>
 * 		<td>request</td>
 * 		<td>String</td>
 * 		<td>to request certain information (e.g. ID)</td>
 * 	</tr>
 *  <tr>
 * 		<td>props</td>
 * 		<td>List&lt;String&gt;</td>
 * 		<td>a List of Strings that contains all the cars properties.<br> The list can contain: "camera", "lights", "winkers", "frontDistanceSensor", "sideDistanceSensors", "velocitySensor" </td>
 * 	</tr>
 *  <tr>
 * 		<td>phnCtrl</td>
 * 		<td>0...1</td>
 * 		<td>to change between control via car-gamepad and linked phone</td>
 * 	</tr>
 * <tr>
 * 		<td>acc</td>
 * 		<td>-128...127</td>
 * 		<td>the acceleration for the car</td>
 * 	</tr>
 * <tr>
 * 		<td>steer</td>
 * 		<td>-128...127</td>
 * 		<td>the steering angle for the car</td>
 * 	</tr>
 * <tr>
 * 		<td>yaw</td>
 * 		<td>-128...127</td>
 * 		<td>the horizontal rotation angle for the cars gimbal</td>
 * 	</tr>
 * <tr>
 * 		<td>ptch</td>
 * 		<td>-128...127</td>
 * 		<td>the vertical rotation angle for the cars gimbal</td>
 * 	</tr>
 * <tr>
 * 		<td>fLts</td>
 * 		<td>0...1</td>
 * 		<td>toggles the front lights</td>
 * 	</tr>
 * <tr>
 * 		<td>bLts</td>
 * 		<td>0...1</td>
 * 		<td>toggles the back lights</td>
 * 	</tr>
 * <tr>
 * 		<td>dynLts</td>
 * 		<td>0...1</td>
 * 		<td>toggles the lights between manual and dynamic mode</td>
 * 	</tr>
 * <tr>
 * 		<td>lWnkr</td>
 * 		<td>0...1</td>
 * 		<td>activates the left winker</td>
 * 	</tr>
 * <tr>
 * 		<td>rWnkr</td>
 * 		<td>0...1</td>
 * 		<td>activates the right winker</td>
 * 	</tr>
 * <tr>
 * 		<td>stop</td>
 * 		<td>0...1</td>
 * 		<td>to send a stop signal to the car, in case the connected phone gets disconnected</td>
 * 	</tr>
 *  <tr>
 * 		<td>uSSen</td>
 * 		<td>0...65535</td>
 * 		<td>the cars ultrasonic-sensor-data</td>
 * 	</tr>
 *  <tr>
 * 		<td>lISen</td>
 * 		<td>0...255</td>
 * 		<td>the cars left-infrared-sensor-data</td>
 * 	</tr>
 *  <tr>
 * 		<td>rISen</td>
 * 		<td>0...255</td>
 * 		<td>the cars right-infrared-sensor-data</td>
 * 	</tr>
 *  <tr>
 * 		<td>hSen</td>
 * 		<td>0...255</td>
 * 		<td>the cars hall-sensor-data</td>
 * 	</tr>
 * </table>
 * 
 * @author Boeck
 *
 */


public abstract class Connection implements Runnable{
	
	/** Holds the connection itself.
	 * The {@link Socket} passed to the constructor of this class needs to have a readTimeout (via setSOtimeout()).*/
	private Socket connection;
	
	/** Holds the inputStream to read from the connected device. */
	private InputStreamReader inputStream;
	
	/** Holds the output-stream to write to the connected device. */
	private OutputStreamWriter outputStream;
	
	/** Contains the key-value-pairs for the JSON-String, to be sent to the connected device. */
	private volatile HashMap<String, Object> outputMessageMap = new HashMap<>();
	
	/** Contains the JSON-map that should be forwarded to the device that is linked to this device via the server. */
	private volatile HashMap<String, Object> forwardMessageMap = new HashMap<>();
	
	/** True, if the runnable should close the connection and finish, otherwise false. */
	private boolean closeConnection = false;
	
	/** The operationQueue can be written to, to inform the main-thread about certain events and send information-relevant data. */
	private volatile LinkedBlockingQueue<QueueElement> operationQueue;
	
	/** The set of DataListeners that want to be informed about new incoming data. */
	private Collection<IDataListener> listeners = new ArrayList<>();
	
	/** The logger that is used for logging messages. Part of the log4j2 library. */
	private static final Logger logger = LogManager.getLogger(Connection.class);
	
	
	/**
	 * Used to initialize this class with a {@link Socket} (the connection itself) and a {@link LinkedBlockingQueue} for communicating with the main-thread. 
	 * @param connection the {@link Socket} for this class. Needs to be pre-configured (priority, read-timeout, etc.),
	 * since this class does not provide means to configure the {@link Socket}.
	 * @param operationQueue this {@link LinkedBlockingQueue} is used to inform the main-thread about certain events and send information-relevant data.
	 */
	public Connection(Socket connection, LinkedBlockingQueue<QueueElement> operationQueue) {
		this.connection = connection;
		this.operationQueue = operationQueue;
		try{
			this.inputStream = new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8);
			this.outputStream = new OutputStreamWriter(connection.getOutputStream(), StandardCharsets.UTF_8);
		} catch(IOException ioe){
			Connection.logger.error("There has been an unexpected IO Exception during the initialization. This Connection cannot be used any longer.", ioe);
			ioe.printStackTrace();
			closeConnection();
		}
	}
	
	
	/**
	 * This method informs all registered listeners about incoming data.
	 * @param decodedDataset the HashMap that contains the incoming message.
	 */
	protected abstract void updateListeners(HashMap<String, Object> decodedDataset);
	
	/**
	 * @return the IP-address of the device, that this Connection is connected to.
	 */
	public String getIpAddress() { return connection.getInetAddress().getHostAddress(); }
	
	/**
	 * @return true, if the runnable should close the connection and finish, otherwise false.
	 */
	public boolean getCloseConnection() { return this.closeConnection; }
	
	/**
	 * Sets the flag, that indicates that the connection with the device should be closed.
	 */
	public void finishConnection() { this.closeConnection = true; }
	
	/**
	 * Adds a new listener to the list of listeners, who get informed about newly received datasets.
	 * @param listener the listener to be added to the list of listeners.
	 * @return true, if the listener was successfully added to the list of listeners, otherwise false.
	 */
	public boolean addListener(IDataListener listener) { return this.listeners.add(listener); }
	
	/**
	 * Removes a listener from the list of listeners, who get informed about newly received datasets.
	 * @param listener the listener to be removed from the list of listeners.
	 * @return true, if the listener was successfully removed from the list of listeners, otherwise false.
	 */
	public boolean removeListener(IDataListener listener) { return this.listeners.remove(listener); }
	
	/**
	 * Returns the list of listeners, that get informed about newly received datasets.
	 * @return the list of listeners.
	 */
	protected Collection<IDataListener> getListeners() { return this.listeners; }
	
	/**
	 * Adds a set of JSON-key-value-pairs to the outputMessageMap.
	 * @param outputMessageMap the set of JSON-key-value-pairs to be added.
	 */
	public void addToOutputMessageMap(HashMap<String, Object> outputMessageMap) { this.outputMessageMap.putAll(outputMessageMap);}
	
	/**
	 * Adds one JSON-key-value-pair to the outputMessageMap.
	 * @param key the key of the JSON-key-value-pair.
	 * @param value the value of the JSON-key-value-pair.
	 */
	public void addToOutputMessageMap(String key, Object value) { this.outputMessageMap.put(key, value); }
	
	/**
	 * Adds a set of JSON-key-value-pairs to the forwardMessageMap.
	 * @param forwardMessageMap the set of JSON-key-value-pairs.
	 */
	public void addToForwardMessageMap(HashMap<String, Object> forwardMessageMap) { this.outputMessageMap.putAll(outputMessageMap);}
	
	/**
	 * Adds one JSON-key-value-pair to the forwardMessageMap.
	 * @param key the key of the JSON-key-value-pair.
	 * @param value the value of the JSON-key-value-pair.
	 */
	public void addToForwardMessageMap(String key, Object value) { this.forwardMessageMap.put(key, value); }
	
	/**
	 * Creates a new {@link QueueElement} with the passed operation-type and this class as parameters and puts it on the {@link #operationQueue}.
	 * @param operationType the operationType for the new {@link QueueElement}
	 * @return true, if the new {@link QueueElement} has been put on the {@link #operationQueue}, otherwise false.
	 */
	protected boolean writeToOperationQueue(EOperationType operationType) {
		if(connection == null)
			return false;
		try {
			this.operationQueue.put(new QueueElement(operationType, this));
			return true;
		} catch(InterruptedException ie) {
		// this should never happen, since we never interrupt a thread
			Connection.logger.error("Unable to put QueueElement on the Operation-Queue.", ie);
		}
		return false;
	}
	
	/**
	 * Reads a maximum of 500 bytes from the {@link Socket}s InputStream, converts it into a String, and returns it.<br>
	 * If an IOException occurs, this runnable will render invalid and therefore finish.
	 * @return the String that was received or null, if nothing was received before an IOException occurred (including a simple Timeout). 
	 */
	protected String readFromStream() {
		try {
			char[] inputBuffer = new char[500];
			if(inputStream.read(inputBuffer, 0, 500) != -1) {
				String inputMessage = (new String(inputBuffer)).trim();
				if(Connection.logger.isDebugEnabled())
					Connection.logger.debug("Incoming message from a " + this.getClass() + ": " + inputMessage);
				return inputMessage;
			}
			else {
				closeConnection();
			}
		} catch(SocketTimeoutException ste) {
			//System.err.println("Socket read timeout.");
		} catch (IOException ioe) {
			// why does this code not work (it does not do anything), but the upper one does???
			if(ioe instanceof SocketTimeoutException){
				System.err.println("Socket read timeout.");
			} else {
				Connection.logger.error("The other end has closed the connection. This Connection cannot be used any longer.");
				closeConnection();
			}
		}
		
		return null;
	}
	
	/**
	 * Reads a maximum of 500 bytes from the {@link Socket}s InputStream, tries to convert it into a HashMap, and returns it.<br>
	 * If an IOException occurs, this runnable will render invalid and therefore finish.
	 * @return the HashMap that was created or null, if nothing was received before an IOException occurred (including a simple Timeout). 
	 */
	protected HashMap<String, Object> readFromStreamToHashMap(){
		String inputMessage = this.readFromStream();
		if(inputMessage != null)
			return JSONDecoder.decode(inputMessage);
		return null;
	}
	
	/**
	 * Writes a String to the {@link Socket}s OutputStream for the connected device to receive it.
	 * @param outputMessage the String that should be sent to the connected device.
	 * @return true, if the write to the outputStream was successful, otherwise false.
	 */
	protected boolean writeToStream(String outputMessage) {
		if(Connection.logger.isDebugEnabled())
			Connection.logger.debug("Sending - " + outputMessage + " - to client.");
		try{
			this.outputStream.write(outputMessage, 0, outputMessage.length());
			this.outputStream.flush();
			return true;
		} catch (IOException ioe) {
			Connection.logger.warn("The other end has closed the connection. This Connection cannot be used any longer.");
			closeConnection();
		}
		return false;
	}
	
	/**
	 * Converts the passed HashMap to a JSON-String and writes that String to the {@link Socket}s {@link #outputStream} for the connected device to receive it.
	 * @param messageMap the HashMap that should be converted to a JSON-String and sent to the connected device.
	 * @return true, if the write to the {@link #outputStream} was successful, otherwise false.
	 */
	protected boolean writeFromMapToStream(HashMap<String, Object> messageMap) {
		if(messageMap == null)
			return false;
		boolean success = false;
		if((success = writeToStream(JSONDecoder.encodeFromMap(messageMap))) && Connection.logger.isDebugEnabled())
			Connection.logger.debug("Sending data to the connected device.");
		return success;
	}
	
	/**
	 * Converts this objects {@link #forwardMessageMap} to a JSON-String and writes that String to the {@link Socket}s {@link #outputStream} of the passed {@link Connection}.
	 * @param conn the {@link Connection} that the {@link #forwardMessageMap} should be written to.
	 * @return true, if the write to the Socket of the passed {@link Connection} was successful, otherwise false.
	 */
	protected boolean forwardMessageToDevice(Connection conn) {
		if(conn == null)
			return false;
		if(Connection.logger.isDebugEnabled())
			Connection.logger.debug("Forwarding the following data from a " + this.getClass() + " to its connected " + conn.getClass() + ":\n" + JSONDecoder.encodeFromMap(this.forwardMessageMap));
		boolean success = conn.writeFromMapToStream(this.forwardMessageMap);
		this.forwardMessageMap.clear();
		return success;
	}
	
	/**
	 * Converts this objects {@link #outputMessageMap} to a JSON-String and writes that String to the {@link Socket}s {@link #outputStream} for the connected device to receive it.
	 * @return true, if the write to the Sockets {@link #outputStream} was successful, otherwise false.
	 */
	public boolean sendOutputMessageMap() {
		boolean success = false;
		if(!this.outputMessageMap.isEmpty()) {
			if(Connection.logger.isDebugEnabled())
				Connection.logger.debug("Sending data to the car.");
			if((success = this.writeFromMapToStream(this.outputMessageMap)))
				this.outputMessageMap.clear();
		}
		return success;
	}
	
	/**
	 * This method waits until the connected device has sent identification information. It also requests identification every 5 seconds that no identification information has been received.
	 * While waiting for identification of the connected device, all other received information is discarded.<br>
	 * If identification has been received, the main-thread is informed about the event.
	 * In this case, the connected device must not yet be informed about the success of the operation.
	 * This is handled by the main-thread in order to be able to conform with the {@link Server}s whitelist.
	 * @return the received id
	 */
	protected Object register(){
		long lastIdRequest = System.currentTimeMillis();
		while(true){
			String inputMessage = this.readFromStream();
			if(inputMessage != null) {
				HashMap<String, Object> decodedDataset = JSONDecoder.decode(inputMessage);
				if(decodedDataset == null)
					continue;
				Object cache;
				// checks if the received message contains identification information. Informs the main-thread and returns the id, if so.
				if((cache = decodedDataset.get(Keywords.id)) != null) {
					writeToOperationQueue(EOperationType.REGISTER);
					return cache;
				}
			}
			if(System.currentTimeMillis() - lastIdRequest > 5000){
				this.outputMessageMap.put(Keywords.request, "id");
				if(Connection.logger.isInfoEnabled())
					Connection.logger.info("Requesting id from the phone.");
				this.writeFromMapToStream(this.outputMessageMap);
				this.outputMessageMap.clear();
			}
		}
	}
	
	/**
	 * Tries to gracefully close the connection, set the closeConnection-flag to true and informs the main-thread about this event through the operationQueue.
	 */
	protected void closeConnection() {
		this.closeConnection = true;
		Connection.logger.info("Closing Channel!");
		if(this.outputStream!= null) {
			try {
				this.outputStream.close();
			} catch(IOException ioe) {}
		}
		if(this.inputStream!= null) {
			try {
				this.inputStream.close();
			} catch(IOException ioe) {}
		}
		if(this.connection != null) {
			try {
				this.connection.close();
			} catch(IOException ioe) {}
		}
		// the connection has been closed, inform the main-thread about this event
		writeToOperationQueue(EOperationType.CLOSE);
	}

	public boolean equals(Object obj) {
		if(this == obj)
			return true;
		if(obj instanceof Connection) {
			return ((Connection) obj).connection.equals(this.connection);
		}
		return false;
	}
	
}
